/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  class JSI_EXPORT NativeHeartPyCxxSpecJSI : public TurboModule {
protected:
  NativeHeartPyCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Object analyze(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Object analyzeSegmentwise(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Object analyzeRR(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeAsync(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeSegmentwiseAsync(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeRRAsync(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) = 0;
  virtual jsi::Object analyzeTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Object analyzeSegmentwiseTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Object analyzeRRTyped(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeAsyncTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeSegmentwiseAsyncTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value analyzeRRAsyncTyped(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) = 0;
  virtual jsi::Array interpolateClipping(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<double> threshold) = 0;
  virtual jsi::Array hampelFilter(jsi::Runtime &rt, jsi::Array signal, std::optional<double> windowSize, std::optional<double> threshold) = 0;
  virtual jsi::Array scaleData(jsi::Runtime &rt, jsi::Array signal, std::optional<double> newMin, std::optional<double> newMax) = 0;
  virtual bool installJSI(jsi::Runtime &rt) = 0;
  virtual jsi::Object getConfig(jsi::Runtime &rt) = 0;
  virtual void setConfig(jsi::Runtime &rt, jsi::Object config) = 0;
  virtual jsi::Value rtCreate(jsi::Runtime &rt, double fs, std::optional<jsi::Object> options) = 0;
  virtual jsi::Value rtPush(jsi::Runtime &rt, double handle, jsi::Array samples, std::optional<double> t0) = 0;
  virtual jsi::Value rtPushTs(jsi::Runtime &rt, double handle, jsi::Array samples, jsi::Array timestamps) = 0;
  virtual jsi::Value rtPoll(jsi::Runtime &rt, double handle) = 0;
  virtual jsi::Value rtSetWindow(jsi::Runtime &rt, double handle, double windowSeconds) = 0;
  virtual jsi::Value rtDestroy(jsi::Runtime &rt, double handle) = 0;
  virtual void addListener(jsi::Runtime &rt, jsi::String eventType) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;

};

template <typename T>
class JSI_EXPORT NativeHeartPyCxxSpec : public TurboModule {
public:
  jsi::Value get(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.get(rt, propName);
  }

  static constexpr std::string_view kModuleName = "HeartPyModule";

protected:
  NativeHeartPyCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeHeartPyCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}

private:
  class Delegate : public NativeHeartPyCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeHeartPyCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {}

    jsi::Object analyze(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyze) == 4,
          "Expected analyze(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyze, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Object analyzeSegmentwise(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeSegmentwise) == 4,
          "Expected analyzeSegmentwise(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyzeSegmentwise, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Object analyzeRR(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeRR) == 3,
          "Expected analyzeRR(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyzeRR, jsInvoker_, instance_, std::move(rrIntervals), std::move(options));
    }
    jsi::Value analyzeAsync(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeAsync) == 4,
          "Expected analyzeAsync(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeAsync, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Value analyzeSegmentwiseAsync(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeSegmentwiseAsync) == 4,
          "Expected analyzeSegmentwiseAsync(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeSegmentwiseAsync, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Value analyzeRRAsync(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeRRAsync) == 3,
          "Expected analyzeRRAsync(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeRRAsync, jsInvoker_, instance_, std::move(rrIntervals), std::move(options));
    }
    jsi::Object analyzeTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeTyped) == 4,
          "Expected analyzeTyped(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyzeTyped, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Object analyzeSegmentwiseTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeSegmentwiseTyped) == 4,
          "Expected analyzeSegmentwiseTyped(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyzeSegmentwiseTyped, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Object analyzeRRTyped(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeRRTyped) == 3,
          "Expected analyzeRRTyped(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::analyzeRRTyped, jsInvoker_, instance_, std::move(rrIntervals), std::move(options));
    }
    jsi::Value analyzeAsyncTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeAsyncTyped) == 4,
          "Expected analyzeAsyncTyped(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeAsyncTyped, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Value analyzeSegmentwiseAsyncTyped(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeSegmentwiseAsyncTyped) == 4,
          "Expected analyzeSegmentwiseAsyncTyped(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeSegmentwiseAsyncTyped, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(options));
    }
    jsi::Value analyzeRRAsyncTyped(jsi::Runtime &rt, jsi::Array rrIntervals, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::analyzeRRAsyncTyped) == 3,
          "Expected analyzeRRAsyncTyped(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::analyzeRRAsyncTyped, jsInvoker_, instance_, std::move(rrIntervals), std::move(options));
    }
    jsi::Array interpolateClipping(jsi::Runtime &rt, jsi::Array signal, double fs, std::optional<double> threshold) override {
      static_assert(
          bridging::getParameterCount(&T::interpolateClipping) == 4,
          "Expected interpolateClipping(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::interpolateClipping, jsInvoker_, instance_, std::move(signal), std::move(fs), std::move(threshold));
    }
    jsi::Array hampelFilter(jsi::Runtime &rt, jsi::Array signal, std::optional<double> windowSize, std::optional<double> threshold) override {
      static_assert(
          bridging::getParameterCount(&T::hampelFilter) == 4,
          "Expected hampelFilter(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::hampelFilter, jsInvoker_, instance_, std::move(signal), std::move(windowSize), std::move(threshold));
    }
    jsi::Array scaleData(jsi::Runtime &rt, jsi::Array signal, std::optional<double> newMin, std::optional<double> newMax) override {
      static_assert(
          bridging::getParameterCount(&T::scaleData) == 4,
          "Expected scaleData(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Array>(
          rt, &T::scaleData, jsInvoker_, instance_, std::move(signal), std::move(newMin), std::move(newMax));
    }
    bool installJSI(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::installJSI) == 1,
          "Expected installJSI(...) to have 1 parameters");

      return bridging::callFromJs<bool>(
          rt, &T::installJSI, jsInvoker_, instance_);
    }
    jsi::Object getConfig(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getConfig) == 1,
          "Expected getConfig(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Object>(
          rt, &T::getConfig, jsInvoker_, instance_);
    }
    void setConfig(jsi::Runtime &rt, jsi::Object config) override {
      static_assert(
          bridging::getParameterCount(&T::setConfig) == 2,
          "Expected setConfig(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::setConfig, jsInvoker_, instance_, std::move(config));
    }
    jsi::Value rtCreate(jsi::Runtime &rt, double fs, std::optional<jsi::Object> options) override {
      static_assert(
          bridging::getParameterCount(&T::rtCreate) == 3,
          "Expected rtCreate(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtCreate, jsInvoker_, instance_, std::move(fs), std::move(options));
    }
    jsi::Value rtPush(jsi::Runtime &rt, double handle, jsi::Array samples, std::optional<double> t0) override {
      static_assert(
          bridging::getParameterCount(&T::rtPush) == 4,
          "Expected rtPush(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtPush, jsInvoker_, instance_, std::move(handle), std::move(samples), std::move(t0));
    }
    jsi::Value rtPushTs(jsi::Runtime &rt, double handle, jsi::Array samples, jsi::Array timestamps) override {
      static_assert(
          bridging::getParameterCount(&T::rtPushTs) == 4,
          "Expected rtPushTs(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtPushTs, jsInvoker_, instance_, std::move(handle), std::move(samples), std::move(timestamps));
    }
    jsi::Value rtPoll(jsi::Runtime &rt, double handle) override {
      static_assert(
          bridging::getParameterCount(&T::rtPoll) == 2,
          "Expected rtPoll(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtPoll, jsInvoker_, instance_, std::move(handle));
    }
    jsi::Value rtSetWindow(jsi::Runtime &rt, double handle, double windowSeconds) override {
      static_assert(
          bridging::getParameterCount(&T::rtSetWindow) == 3,
          "Expected rtSetWindow(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtSetWindow, jsInvoker_, instance_, std::move(handle), std::move(windowSeconds));
    }
    jsi::Value rtDestroy(jsi::Runtime &rt, double handle) override {
      static_assert(
          bridging::getParameterCount(&T::rtDestroy) == 2,
          "Expected rtDestroy(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::rtDestroy, jsInvoker_, instance_, std::move(handle));
    }
    void addListener(jsi::Runtime &rt, jsi::String eventType) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventType));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }

  private:
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
